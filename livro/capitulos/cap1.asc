== Noções Básicas dos Erros

.Objetivos do capítulo
____
Ao final deste capítulo você deverá ser capaz de:

* Representar números no computador;

* Converter números do sistema decimal a  binário, e vice-versa;

* Entender o conceito de Sistema de Ponto Flutuante Normalizado;

* Relacionar-se cada vez mais com os conceitos de erros absoluto e
  relativo, e as implicações destes tipos de erros num sistema de ponto
  flutuante;

* Realizar operações aritméticas com números de um sistema de ponto flutuante dado,
  e entender a propagação de seus erros.  
____


Em forma geral, a resolução de qualquer problema se inicia pela observação, logo, usando
conceitos que não serão estudados neste livro, é possível concebê-lo em termos científicos, o que visa a construção de um modelo matemático que deve representar da melhor forma possível o problema
em estudo. Por este motivo, este procedimento é conhecido como fase de
modelagem.

Imprecisões como:

... Simplificação do modelo matemático, necessário para a obtenção de um modelo matemático solúvel; 
... Erro de truncamento, devido à troca de uma serie infinita por uma finita;
... Erro de arredondamento, devido à própria estrutura da máquina; 
... Erro na obtenção dos dados, dados imprecisos obtidos de experimentos ou arredondados na entrada;
... etc. 

podem surgir na fase de modelagem, a menos que algumas medidas sejam
consideradas, é isto implica na diminuição da precisão dos resultados
obtidos ou na obtenção de resultados incorretos.

Pelo exposto, neste capítulo, focaremos a nossa atenção no estudo dos
erros, que possam surgir na resolução de um determinado problema,
assim como, os erros que surgem da representação de um número no
computador e os erros das operações efetuadas. A seguinte figura
esquematiza os passos que se seguem para resolver um problema dado:


image::images/cap1/fases.eps[scaledwidth="80%"]

=== Representação dos números no computador


Poderíamos, sempre, esperar que afirmações como 
[latexmath]
++++
\[2+3=5, \quad 2\times 3=6\quad \mbox{e}\quad \left( \sqrt{2}\right)^2 =2,\]
++++
sejam verdadeiras ou válidas num computador. Não entanto, a aritmética
executada por um computador é diferente daquela utilizada na
Matemática, isto é, num computador estardar, esperamos resultados
exatos para 

[latexmath]
++++
\[2+3=5\quad \mbox{e}\quad 2\times 3=6;\]
porém, não necessáriamente obteremos de forma precisa 
\[\left( \sqrt{2}\right)^2 =2,\]
++++
e isto se explicará conhecendo a aritmética que trabalha com um número
finito de algarismos.


Na matemática, existem números que são expressos com uma quantidade
infinita de algarismos, por exemplo:

[latexmath]
++++
\[\pi= 3.14159 26535\dots, \quad \sqrt{2}=1.4142135623\dots,\quad 
\frac{1}{3}=0.3333333333\dots,
\]
++++
entretanto, no computador, cada número pode ser representado com
apenas um número fixo e finito de algarismos, o que implica que
números como latexmath:[$\pi$, $\sqrt{2}$ e $\frac{1}{3}$] não podem
ser representados de forma exata, e por este motivo recebem uma
representação aproximada a qual deverá ser suficientemente próxima do
valor exato e será considerada aceitável na maioria das situações.
Embora, muitas vezes, a aritmética usada no computador seja
satisfatória, quase sempre surgem problemas devido a esta limitação.

 
Comumente, os computadores trabalham os números reais representando-os
no sistema binário, a diferença do sistema decimal que normalmente
usamos. De fato, quando introduzimos uma informação numérica no
computador, esta é automaticamente transformada em sua representação
binária (exata ou aproximada), porém, em muitas situações, dita
transformação pode acarretar em erros, devido à limitação da sua
representação. A implicação deste fato, é que uma simples operação
aritmética entre números representados no computador pode já
apresentar erros; para evitar isto devem ser consideradas certas
formas de conter as imprecisões decorrentes de fatores tanto internos
como de externos.  

 

=== Conversão de números do sistema decimal a  binário, e vice-versa

Dados os números:
[latexmath]
++++
\[
(271.375)_{10}\quad \mbox{e}\quad (11010.000111)_2.
\]
++++
Qual é sua representação binária e decimal, respectivamente? Nesta
seção, estudaremos e/ou lembraremos como realizar dita conversão.
Comecemos estudando e/ou lembrando a conversão dos números inteiros. 

===== Conversão de um número inteiro da base 2 para a base 10

Dados os números inteiros na base binária latexmath:[$(11010)_{2}$ e
$(1111111)_{2}$], sabemos que estes podem ser reescritos da seguinte
forma:

[latexmath]
++++
\[
\begin{array}{ccl}
(11010)_{2}&=& 1\times 2^4 + 1\times 2^3 +0\times 2^2 + 1\times  2^1 + 0 \times 2^0 ;\\
(111111)_{2}&=& 1\times 2^6+1\times 2^5+1\times 2^4 + 1\times 2^3 +1\times 2^2 + 1\times  2^1 + 1 \times 2^0.
\end{array}
\]
++++

De forma geral, dada uma base latexmath:[$\beta\geq 2$], um número
nesta base será representado por: 

[latexmath]
++++
\[
(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{\beta},\quad\mbox{com}\quad 0\leq a_j \leq (\beta-1),\quad j=0,\ldots, i,
\]
porém, ele pode ser reescrito da seguinte forma:
\[
(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{\beta}= a_{i}\times \beta^{i} + a_{i-1} \times \beta^{i-1} + \cdots +a_2 \times \beta^{2}+ a_1 \times \beta^{1} + a_0\times \beta^{0} = \sum\limits_{j=0}^{i} a_{j}\times \beta^{j}.
\]
++++

Note que ao efetuar o somatório latexmath:[$\sum\limits_{j=0}^{i} a_{j}\times \beta^{j}$ o 
resultado já é um número decimal. Portanto,
da representação acima, dada uma base  $\beta\geq 2$, podemos
converter qualquer número expresso nesta base para sua representação
na base $10$].


.{zwsp}
====
.. latexmath:[$(11010)_{2}= 1\times 2^4 + 1\times 2^3 +0\times 2^2 + 1\times  2^1 + 0 \times 2^0 =(26)_{10}$].
Porém, podemos reescrever 
+
[latexmath]
++++
\[
\begin{array}{ccl}
(26)_{10} &=& 2\times (2\times (2\times (2\times 1+1)+0)+1)+0.
\end{array}
\]
++++

.. latexmath:[$(1111111)_{2}= 1\times 2^6+1\times 2^5+1\times 2^4 + 1\times 2^3 +1\times 2^2 + 1\times  2^1 + 1 \times 2^0 =(127)_{10}$].
Porém,  podemos reescrever 
+
[latexmath]
++++
\[
\begin{array}{ccl}
(127)_{10} &=& 2\times(2\times (2\times (2\times (2\times (2\times 1+1)+1)+1)+1)+1)+1.
\end{array}
\]
++++

====


Nestes exemplos, vemos intuitivamente que podemos obter uma forma para
converter um número da base binária para a base decimal. Assim, a
teoria estabelece que, dado um número na base  latexmath:[$2$: $(a_{i}
a_{i-1} \ldots a_2 a_1 a_0)_{2}$ a sua representação na base $10$,
denotada por $b_0$], é obtida da seguinte forma:


[latexmath]
++++
\[
\begin{array}{ccl}
b_{i}&=& a_{i};\\
b_{i-1}&=& 2 \times b_{i}+a_{i-1};\\
b_{i-2}&=& 2 \times b_{i-1}+a_{i-2};\\
     &\vdots& \\
b_{1}&=& 2 \times b_{2}+a_1;\\
b_{0}&=& 2 \times b_{1}+a_{0}.
\end{array}
\]
++++


.{zwsp}
====
Do exemplo anterior, temos que os valores dos latexmath:[$b_i$] são:

..  latexmath:[$\,$]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{4}&=& a_{4} &=&1; &&\\
b_{3}&=& 2 \times b_{4}+a_{3} &=&  2\times 1  +1 &=& 3;\\
b_{2}&=& 2 \times b_{3} +a_2&=&  2\times 3  +0 &=& 6;\\
b_{1}&=& 2 \times b_{2} +a_1&=&  2\times 6  +1 &=& 13;\\
b_{0}&=& 2 \times b_{1}+a_0 &=&  2\times 13 +0 &=& 26.
\end{array}
\]
++++

..  latexmath:[$\,$]
+
[latexmath]
++++
\[
\begin{array}{cclclcl}
b_{6}&=& a_{6} &=&1; &&\\
b_{5}&=& 2 \times b_{6}+a_{5} &=&  2\times 1  +1 &=& 3;\\
b_{4}&=& 2 \times b_{5} +a_4&=&  2\times 3  +1 &=& 7;\\
b_{3}&=& 2 \times b_{4}+a_{3} &=&  2\times 7  +1 &=& 15;\\
b_{2}&=& 2 \times b_{3} +a_2&=&  2\times 15  +1 &=& 31;\\
b_{1}&=& 2 \times b_{2} +a_1&=&  2\times 31  +1 &=& 63;\\
b_{0}&=& 2 \times b_{1}+a_0 &=&  2\times  63+1 &=& 127.
\end{array}
\]
++++
====



===== Conversão de um número inteiro da base 10 para a base 2

No seguinte exemplo, vamos converter um número inteiro da base decimal
para a base binária.


.{zwsp}
====
Considere o número latexmath:[$b_0= (271)_{10}$ e a sua representação
em binário $(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{2}$], isto é,

[latexmath]
++++
\[
\begin{array}{rcl}
(271)_{10} &=&(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{2}\\
       &=& a_{i}\times 2^{i} + a_{i-1} \times 2^{i} + \cdots +a_2 \times 2^{2}+ a_1 \times 2^{1} + a_0\times 2^{0}\\
&=& 2 \times \left( a_{i}\times 2^{i-1} + a_{i-1} \times 2^{i-2} + \cdots +a_2 \times 2^{1}+ a_1 \times 2^{0}\right)  + a_0\\
&=& 2 \times 135 + 1.
\end{array}
\]
++++
Logo, latexmath:[$a_0=1$, e representa o resto da divisão de $271$ 
por $2$. Repetindo o processo para $b_1=135$] temos  

[latexmath]
++++
\[
\begin{array}{rcl}
135    &=& a_{i}\times 2^{i-1} + a_{i-1} \times 2^{i-2} + \cdots a_2 \times 2^{1}+ a_1\\ 
       &=& 2 \times \left( a_{i}\times 2^{i-2} + a_{i-1} \times 2^{i-3} + \cdots a_2 \times 2^{0} \right) + a_1 \\
&=& 2 \times 67 + 1.
\end{array}
\]
++++

Assim, latexmath:[$a_1=1$, e representa o resto da divisão de
$b_1=135$ por $2$. Repetindo este processo sucessivamente obtemos os
seguintes $b_i'$s e $a_i'$]s:

[latexmath]
++++
\[
\begin{array}{lclcl}
b_0 =271 &=& 2\times 135 +1 &\Rightarrow& a_0 = 1;\\
b_1 =135 &=& 2\times 67  +1 &\Rightarrow& a_1 = 1;\\
b_2 =67  &=& 2\times 33  +1 &\Rightarrow& a_2 = 1;\\
b_3 =33  &=& 2\times 16  +1 &\Rightarrow& a_3 = 1;\\
b_4 =16  &=& 2\times 8   +0 &\Rightarrow& a_4 = 0;\\
b_5 =8   &=& 2\times 4   +0 &\Rightarrow& a_5 = 0;\\
b_6 =4   &=& 2\times 2   +0 &\Rightarrow& a_6 = 0;\\
b_7 =2   &=& 2\times 1   +0 &\Rightarrow& a_7 = 0;\\
b_8 =1   &=& 2\times 0   +1 &\Rightarrow& a_8 = 1.
\end{array}
\]
Portanto, 
\[
(271)_{10}= (100001111)_{2}.
\]
++++
====

Neste exemplo, vimos intuitivamente que podemos obter uma forma para
converter um número da base decimal para a base binária. Assim, a
teoria estabelece que, dado um número inteiro latexmath:[$n$ na base
decimal, com  $(a_{i} a_{i-1} \ldots a_2 a_1 a_0)_{2}$, como sua
representação binária, podemos obter o digito binário $a_k$ para cada
$k$, $k=0,1,\dots,i$], usando o seguinte algoritmo:

Algoritmo 1.1::

Passo 0: :::  latexmath:[$k=0$]
+
[latexmath]
++++
\[
n_k=n.
\]
++++

Passo 1: :::  Obtenha latexmath:[$q_k$ e $r_k$] tais que:
+
[latexmath]
++++
\[
n_k=2\times q_k + r_k.
\]
++++
+
Faça latexmath:[$a_k=r_k.$]

Passo 2: :::  Se latexmath:[$q_k = 0$], *PARE*.
+
Caso contrário, faça latexmath:[$n_{k+1}=q_k$].
+
Faça latexmath:[$k=k+1$] e volte para o *Passo 1*.


===== Conversão de um número fracionário da base 10 para a base 2

Abordaremos agora a representação de um número fracionário da base
latexmath:[$10$] para a base binária.

.{zwsp} 
====
Consideremos o número latexmath:[$n=0.375$, logo, existem os dígitos
binários $d_1,d_2,\ldots,d_i,\ldots$], tais que:

[latexmath]
++++
\[n=0.375=(0.d_1d_2\ldots d_i \ldots)_2.
\]
Então
\[
(0.375)_{10}= (0.d_1d_2\ldots d_i \ldots)_2= d_1 \times 2^{-1} + d_2\times 2^{-2} + \cdots + d_i \times 2^{-i} +\cdots
\]
++++

Ao multiplicar cada termo da expressão acima por latexmath:[$2$] obtemos:
[latexmath]
++++
\[
2\times 0.375 = 0.75= 0+ 0.75= d_1  + d_2\times 2^{-1} + d_3\times 2^{-2} +\cdots + d_i \times 2^{-i+1} +\cdots
\]
++++
Assim, latexmath:[$d_1=0$ representa a parte inteira de $2\times 0.375$] e 
[latexmath]
++++
\[
0.75 = d_2\times 2^{-1} + d_3\times 2^{-2} +\cdots + d_i \times 2^{-i+1} +\cdots
\]
++++

representa a parte fraccionária de latexmath:[$2\times 0.375$].
Repetindo novamente este procedimento para latexmath:[$0.75$]:

[latexmath]
++++
\[
0.75= d_2 \times 2^{-1} + d_3\times 2^{-2} + \cdots + d_i \times 2^{-i+1} +\cdots
\]
++++

Ao multiplicar cada termo da expressão anterior por  latexmath:[$2$]
obtemos:

[latexmath]
++++
\[
2\times 0.75 = 1.5= 1+ 0.5= d_2 + d_3\times 2^{-1}+d_4\times 2^{-2} +\cdots + d_i \times 2^{-i+2} +\cdots
\]
++++

Assim, latexmath:[$d_2=1$ representa a parte inteira de $2\times 0.75$] e 
[latexmath]
++++
\[
0.5 = d_3\times 2^{-1}+d_4\times 2^{-2} +\cdots + d_i \times 2^{-i+2} +\cdots
\]
++++

representa a parte fraccionária de latexmath:[$2\times 0.75$].
Repetindo novamente o procedimento para o número latexmath:[$0.5$]:

[latexmath]
++++
\[
0.5= d_3\times 2^{-1}+d_4\times 2^{-2} +\cdots + d_i \times 2^{-i+2} +\cdots
\]
++++

Ao multiplicar cada termo da expressão anterior por latexmath:[$2$] obtemos:

[latexmath]
++++
\[
2\times 0.5 = 1.0= 1+ 0.0= d_3 +d_4\times 2^{-1} +\cdots + d_i \times 2^{-i+3} +\cdots
\]
++++

Assim, latexmath:[$d_3=1$ representa a parte inteira de $2\times 0.5$] e 
[latexmath]
++++
\[
0.0 = +d_4\times 2^{-1} +\cdots + d_i \times 2^{-i+3} +\cdots
\]
++++

representa a parte fraccionária de latexmath:[$2\times 0.5$, e como a
parte fracionária é zero, o processo termina. Assim, $d_1=0$, $d_2=0$,
$d_3=1$]. Portanto 

[latexmath]
++++
\[
(0.375)_{10}= (0.001)_2.
\]
++++
====

[NOTE]
====
No exemplo acima, temos que latexmath:[$n=0.375$] tem uma
representação finita na base binária, porém isto  não necessariamente
é verdadeiro na maiora dos casos. De forma geral, dado um número
latexmath:[$n\in (0,1)$, embora tenha representação finita no sistema
decimal, a sua representação na base $2$] pode ser finita ou infinita.
O próximo exemplo, ilustrará este fato.

====
	

De forma geral, consideremos um número latexmath:[$n\in(0,1)$ no
sistema decimal e $(0.d_1 d_2 \ldots d_i \ldots)_2$], sua
representação no sistema binário. Logo, os dígitos binários
latexmath:[$d_1, d_2, \ldots, d_i, \ldots $] são obtidos usando o
seguinte algoritmo:

Algoritmo 1.2::

Passo 0:::  latexmath:[$k=1$]
+
[latexmath]
++++
\[
r_1=n.
\]
++++
Passo 1:::  Calcule latexmath:[$2 \times r_k$. Se $2\times r_k \geq 1$, faça $d_k=1$]. +
Caso contrário, faça latexmath:[$d_k=0$]
Passo 2::: Faça latexmath:[ $r_{k+1} = 2\times r_k -d_k$. Se $r_{k+1}=0$], *PARE*. +
Caso contrário, faça latexmath:[$k=k+1$] e volte para o *Passo 1*.
 

[NOTE]
Da nota anterior, o *Algoritmo 1.2* pode ou não parar após um número finito de iterações. 

.{zwsp} 
====
No exemplo anterior, temos que para latexmath:[$n=(0.375)_{10}$,
$r_4=0$. Agora consideremos $n=(0.2)_{10}$]. Logo, aplicando o
*Algoritmo 1.2* obtemos: 

[latexmath]
++++
\[
\begin{array}{llll}
 k=1:& r_1=0.2;\\
&2\times r_1 = 0.4<1 & \Rightarrow 
\left\{ \begin{array}{lcl}
d_1 & = & 0;\\
r_2 & = & 0.4;
\end{array}
   \right.\\
k=2: & 2\times r_2 = 0.8<1 & \Rightarrow 
\left\{ \begin{array}{lcl}
d_2 & = & 0;\\
r_3 & = & 0.8;
\end{array}
   \right.\\	
k=3: & 2\times r_3 = 1.6 \geq 1& \Rightarrow 
\left\{ \begin{array}{lcl}
d_3 & = & 1;\\
r_4 & = & 0.6;
\end{array}
   \right.\\
k=4: & 2\times r_4 = 1.2 \geq 1& \Rightarrow 
\left\{ \begin{array}{lclcl}
d_4 & = & 1;&&\\
r_5 & = & 0.2 &=& r_1.
\end{array}
   \right.\\
\end{array}
\]
++++

Desde que latexmath:[$r_5=r_1$, os resultados obtidos para $k$ de 1
até 4 serão repetidos. Mais ainda,  $0.2=r_1=r_5=r_9=r_{13}\dots$] e
assim por diante.  Portanto

[latexmath]
++++
\[
(0.2)_{10} = (0.001100110011\ldots)_2=(0.\overline{0011})_2.
\]
++++
====
[NOTE]
====
A situação vista no exemplo acima, isto é, dado um número na base
decimal com representação finita e com representação infinita na base
binária, pode gerar erros, não detectáveis por nós, nos resultados
obtidos usando  sistemas computacionais que trabalhem no sistema
binário.  De fato, ao trabalhar com latexmath:[$(0.2)_{10}$] no
computador, ele trabalhará com uma aproximação de
latexmath:[$(0.2)_{10}$], devido a que o computador possui uma
quantidade fixa de posições para guardar os dígitos da mantissa de um
número, e tal aproximação será usada para realizar os cálculos.
Portanto, não podemos aguardar um resultado exato. 

====

===== Conversão de um número fracionário da base 2 para a base 10

Dado um número fracionário na base 2, denotado por latexmath:[$(r)_2$], isto é,
[latexmath]
++++
\[
(r)_2=(0.d_1 d_2 \ldots d_i \ldots)_2
\]
++++
obteremos a sua representação na base decimal. 

O algoritmo que apresentaremos para fazer esta transformação é
equivalente ao descrito previamente. Inicialmente definimos
latexmath:[$r_1=r$, a em cada iteração $k$, o processo multiplica o
número $r_k$ por $(10)_{10} = (1010)_2$ para obter o digito $b_k$]
como sendo a parte inteira deste produto convertida para a base
decimal. Notemos que estas operações devem ser realizadas no sistema
binário.


Algoritmo 1.3::

Passo 0:::  latexmath:[$k=1$]
+
[latexmath]
++++
\[
r_1=r.
\]
++++
Passo 1:::  Calcule latexmath:[$w_k=(1010)_2 \times r_k$]. + 
Seja latexmath:[$z_k$] a parte inteira de latexmath:[$w_k$]. +
Faça latexmath:[$b_k$]  igual à conversão de latexmath:[$z_k$] para a base 10.

Passo 2::: Faça latexmath:[$r_{k+1} = w_k -z_k$. Se $r_{k+1}=0$], *PARE*.

Passo 3::: Faça latexmath:[$k=k+1$] e volte para o *Passo 1*.
   
.{zwsp} 
==== 
Dado o número latexmath:[$(r)_2 = (0.000111)_2$], determinemos a sua representação em base 10. 

Solução::
Desde que, latexmath:[$(r)_2 = (0.000111)_2$], temos:
+
[latexmath]
++++
\[
(0.000111)_2=(0.b_1 b_2 \ldots b_j)_{10}.
\]
Do {\bf Algoritmo 1.3}
\[
\begin{array}{llll}
k=1:&r_1=(0.000111)_2;\\
&w_1= (1010)_2\times r_1 = 1.0001 & \Rightarrow 
\left\{ \begin{array}{lcl}
b_1 & = & 1;\\
r_2 & = & 0.00011\neq 0;
\end{array}
   \right.\\
k=2: & w_2=(1010)_2 \times r_2 = 0.1111 & \Rightarrow 
\left\{ \begin{array}{lcl}
b_2 & = & 0;\\
r_3 & = & 0.1111\neq 0;
\end{array}
   \right.\\	
k=3: & w_3=(1010)_2\times r_3 = 1001.011 & \Rightarrow 
\left\{ \begin{array}{lcl}
b_3 & = & 9;\\
r_4 & = & 0.011\neq 0;
\end{array}
   \right.\\
k=4: & w_4=(1010)_2\times r_4 = 11.11 & \Rightarrow 
\left\{ \begin{array}{lcl}
b_4 & = & 3;\\
r_5 & = & 0.11\neq 0;
\end{array}
   \right.\\
k=5: & w_5= (1010)_2\times r_5 = 111.1 & \Rightarrow 
\left\{ \begin{array}{lcl}
b_5 & = & 7;\\
r_6 & = & 0.1\neq 0;
\end{array}
   \right.\\
k=6: & w_6=(1010)_2\times r_6 = 101 & \Rightarrow 
\left\{ \begin{array}{lcl}
b_6 & = & 5;\\
r_7 & = & 0;
\end{array}
   \right.\\
\end{array}
\]
Portanto,
\[
(0.000111)_2 = (0.109375)_{10}.
\]
++++
====

[NOTE]
====
Um número fracionário numa determinada base, sempre será um número
fracionário em qualquer outra base.

====

Assim, a seguinte nota responder à pergunta feita no inicio desta
seção, além disso, ilustraremos isto com o próximo exemplo.

[NOTE]
====
Se o número em questão tem uma parte inteira e uma parte fracionária,
então a sua conversão, em outra base, será obtida decompondo este na
soma da parte inteira com a parte fracionária, logo aplicaremos os
algoritmos respectivos a cada parte. 

====

.{zwsp}
====
.. Dado o número latexmath:[$ (271.375)_{10}$], determinemos a sua
   representação em base 2.

Solução::
Desde que
+
[latexmath]
++++
\[
(271.375)_{10}=(271)_{10}+(0.375)_{10}.
\]
Do {\bf Exemplos 1.3(a)} e {\bf 1.4}, temos que
\[
(271)_{10}=(100001111)_2 \quad \mbox{e} \quad (0.375)_{10}=(0.001)_2,
\]
respectivamente. Portanto
\[
(271.375)_{10}=(100001111)_2 +(0.001)_2=(100001111.001)_2.
\]
++++
.. Dado o número latexmath:[$ (11010.000111)_2$], determinemos a sua
   representação em base 10. 

Solução::
Desde que
+
[latexmath]
++++
\[
(11010.000111)_2=(11010)_2+(0.000111)_2.
\]
Do {\bf Exemplo 1.1(a)} e o exemplo anterior, temos que
\[
(11010)_2=(26)_10 \quad \mbox{e} \quad (0.000111)_2=(0.109375)_{10},
\]
respectivamente. Portanto
\[
(11010.000111)_2=(26)_10+(0.109375)_{10}=(26.109375)_{10}.
\]
++++


====


=== Sistema de Ponto Flutuante Normalizado

Como mencionado previamente, no computador, apenas um subconjunto dos
números reais é representado exatamente,  portanto dado qualquer
número real a sua representação aproximada será efetuada por
truncamento ou arredondamento. Esta representação é denominada de
*ponto flutuante normalizado*.

De forma geral, para representar um número no sistema de ponto
flutuante normalizado, em geral, precisamos de uma base
latexmath:[$\beta\geq 2$, um número de dígitos significativos $n$ e um
exponente ${\rm exp}$].

Definição 1.1:: 

... Dado um número real latexmath:[$nr$]. Diz-se que latexmath:[$nr$]
está representado no sistema de ponto flutuante normalizado se for
possível representá-lo na forma:
+
[latexmath]
++++
\[
{nr}= \pm (0.d_1 d_2 \ldots d_n)\times \beta^{{\rm exp}}
\]
++++
+
onde: 
+
--
* latexmath:[$\beta \geq 2$] é a base do sistema;

* latexmath:[$n$] é o número de dígitos na mantissa; 
+
[latexmath]
++++
\[0\leq d_i \leq (\beta-1), \quad i=1,\ldots, n,\quad\mbox{com}\quad d_1 \neq 0;
\]
++++

* latexmath:[${\rm exp}$ é o expoente no intervalo $[{\rm exp}_{{\rm
  min}}, {\rm exp}_{{\rm max}}\]$, com ${\rm exp}_{{\rm min}} \leq 0$
  e ${\rm exp}_{{\rm max}} \geq 1$] inteiros.
--

... Desde que latexmath:[$d_1 \neq 0$], o zero é representado da seguinte forma:
+
[latexmath]
++++
\[
\mbox{\bf zero}= 0.\underbrace{000000\ldots 0}_{n\,\,\mbox{vezes}} \times \beta^{\exp_{\rm min}} 
\]
++++

... A união de todos os números em ponto flutuante, juntamente com o
*zero*, define o *sistema de ponto flutuante normalizado*, que será
denotado por latexmath:[${\rm SPF}(\beta,n,\exp_{{\rm min}},
\exp_{{\rm max}})$].

[NOTE]
====
Dado o  latexmath:[${\rm SPF}(\beta,n,\exp_{{\rm min}}, \exp_{{\rm max}})$] temos que:


.. O menor número positivo exatamente representável, denotado por latexmath:[${\rm m}$],  é dado por:
+
[latexmath]
++++
\[
{\rm m}= 0.1\underbrace{000000\ldots 0}_{(n-1)\,\,\mbox{vezes}} \times \beta^{\exp_{\rm min}};
\]
++++
.. O maior número positivo exatamente representável, denotado por latexmath:[${\rm M}$], é dado por:
+
[latexmath]
++++
\[
{\rm M}= 0 \times \underbrace{[\beta-1][\beta-1]\ldots [\beta-1]}_{n\,\,\mbox{vezes}} \times \beta^{\exp_{\rm max}} 
;\]
++++
.. O número máximo de mantissas positivas possíveis, denotado por latexmath:[${\rm mantissas_{possíveis}}$], é dado por:
+
[latexmath]
++++
\[
{\rm mantissas}_{\rm possíveis}= (\beta-1) \times \beta^{n-1} ;
\]
++++
.. O número máximo de expoentes possíveis, denotado por latexmath:[$\exp_{\rm possíveis}$], é dado por:
+
[latexmath]
++++
\[
\exp_{\rm possíveis}= \exp_{\rm max} - \exp_{\rm min} +1;
\]
++++
..  O número de elementos positivos representáveis, denotado por
    latexmath:[${\rm NumR}_{+}$], é dado por:
+
[latexmath]
++++
\[
{\rm NumR}_{+}=\mbox{mantissas}_{\rm possiveis} \times \exp_{\rm possiveis};
\]
++++

.. Dado um número real latexmath:[${ nr}\in {\rm SPF}$, temos que  $-{
   nr}\in {\rm SPF}$, assim o número total de elementos
   representáveis, denotado por ${\rm NumR}_{\rm T}$], junto à
   representação do *zero*, é dado por:
+
[latexmath]
++++
\[
{\rm NumR}_{\rm T} = 2\times {\rm NumR}_{+}+1.
\]
++++

====

O seguinte exemplo ilustra os conceitos da nota acima.

.{zwsp}
====
Se consideramos o sistema de ponto flutuante latexmath:[${\rm
SPF}(\beta,n,\exp_{\rm min}, \exp_{\rm max}) ={\rm SPF}(10,3,-5,5)$].
Logo, os números serão representados da seguinte forma:

[latexmath]
++++
\[
0.d_1 d_2 d_3 \times 10^{\exp}, \quad 0\leq d_i \leq 9, \quad d_1\neq 0, \quad \exp \in [-5,5].
\]
++++
Portanto,

.. latexmath:[${\rm m}=0.100 \times 10^{-5}= 10^{-6}$];
.. latexmath:[${\rm M}=0.999 \times 10^{5}= 99900$];
.. latexmath:[${\rm mantissas}_{\rm possiveis}=(10-1)\times 10^{3-1}= 900$];
.. latexmath:[$\exp_{\rm possíveis}=5-(-5)+1=11$];
.. latexmath:[${\rm NumR}_{+}=900\times 11=9900$];
.. latexmath:[${\rm NumR}_{\rm T}=2\times 9900 + 1 = 19801$].

====

Agora, consideremos o conjunto dos números reais, denotado por
latexmath:[$\mathbb{R}$, ${\rm SPF}(10,3,-5,5)$], e o conjunto 

[latexmath]
++++
\[
A:=\left\{ x\in \mathbb{R}\,:\,{\rm m}\leq |x| \leq {\rm M}  \right\}.
\]
++++
Logo, dado latexmath:[$x\in \mathbb{R}$] temos as seguintes possibilidades:

... Se latexmath:[$x\in A$, por exemplo $x=135.87= 0.13587 \times
10^{3}$. Note-se que $x$ tem $5$ dígitos na mantissa. Por outro lado,
os números $0.135\times 10^3$ e $0.136\times 10^3$ estão representados
exatamente em ${\rm SPF}(10,3,-5,5)$]. Assim,
+
--
.. por truncamento: 
+
[latexmath]
++++
\[
nr_x=0.135\times 10^3;
\]
++++
.. por arredondamento:
+
[latexmath]
++++
\[
nr_x=0.136\times 10^3;
\]
++++
--

... Se latexmath:[$|x| < {\rm m}$,  por exemplo $x=0.123 \times
10^{-6}$. Este número não pode ser representado  em ${\rm
SPF}(10,3,-5,5)$, devido a que o expoente $\exp=-6 \leq -5 = \exp_{\rm
min}$]. Nesta  situação o sistema acusará *underflow*;

... Se latexmath:[$|x| > {\rm M}$,  por exemplo $x=0.456 \times
10^{7}$. Este número não pode ser representado em ${\rm
SPF}(10,3,-5,5)$, devido a que o expoente $\exp=7 \geq 5 =
\exp_{\max}$]. Nesta  situação o sistema acusará *overflow*. 


[NOTE]
Algumas linguagem de programação permitem que as variáveis possam ser
declaradas com precisão dupla, e isto implica que a variável utilizará
o dobro de dígitos disponíveis na mantissa, o que acarretará no
aumento do tempo de execução e requerimentos de memória.


=== Erros

Nas medições cientificas, quando se aproxima um número real
latexmath:[$x$ mediante outro número $\overline{x}$, o erro que
resulta é $x-\overline{x}$], isto é:

[latexmath]
++++
\[
{\rm Erro}= x-\overline{x}.
\]
++++

Porém, dependendo da magnitude da quantidade que esta sendo medida,
tal erro pode ser aceitável ou não. Por exemplo, se perguntamos a uma
pessoa: Qual é a distância entre a Terra e a Lua? e esta responde:
384401 kms, seria algo assombroso, pois erro somente será de 1 km,
porém este tipo de erro não seria aceitável no pouso de uma aeronave.
Por este motivo precisamos estabelecer conceitos fundamentais para o
bom entendimento desta teoria.

==== Erro Absoluto

Definição 1.1:: O *erro absoluto*, denotado por latexmath:[${\rm
EA}_x$, é a diferença entre o valor exato de um número $x$ e de seu
valor aproximado $\overline{x}$], isto é:
+
[latexmath]
++++
\[
{\rm EA}_x = x-\overline{x}.
\]
++++


Como na maioria das vezes o valor exato não está disponível, é
necessário trabalhar com um limitante superior ou uma estimativa para
o módulo do erro absoluto.

.{zwsp}
====
.. Dados  latexmath:[$\pi$ e  $\overline{\pi}$, com $\overline{\pi}$
   sendo qualquer valor no intervalo aberto $(3.14, 3.15)$]. Temos que 
+
[latexmath]
++++
\[
|{\rm EA}_{\pi}|= | \pi - \overline{\pi}|< 0.01;
\]
++++
.. Dados latexmath:[$x$ e $\overline{x}$, com $\overline{x}= 332.9$] tal que:
+ 
[latexmath]
++++
\[
|{\rm EA}_x|< 0.1.\quad \mbox{Então} \quad x\in (332.8, 333);
\]
++++
.. Dados latexmath:[$y$ e $\overline{y}$, com $\overline{y}= 1.4$] tal que:
+ 
[latexmath]
++++
\[
|{\rm EA}_y|<0.1.\quad\mbox{Então}\quad y\in (1.3,1.5). 
\]
++++
====

Embora, os números latexmath:[$x$ e $y$] estão sendo representados com
a mesma precisão, necessitamos saber a ordem de grandeza deles para
obter uma maior precisão em nossos cálculos. Por este motivo,
precisamos conhecer o conceito de *erro relativo*.

==== Erro Relativo

Definição 1.2:: O *erro relativo*, denotado por  latexmath:[${\rm
ER}_x$], é o erro absoluto dividido pelo seu valor aproximado, isto é:

+
[latexmath]
++++
\[
{\rm ER}_x = \frac{{\rm EA}_x}{\overline{x}} = \frac{x- \overline{x}}{\overline{x}}.
\]
++++

Podemos notar que o erro relativo proporciona mais informações sobre a
qualidade do erro que estamos cometendo num determinado calculo, já
que a ordem de grandeza do valor calculado é contemplada.

.{zwsp}
====
Do exemplo anterior, temos que:
[latexmath]
++++
\[
|{\rm ER}_x|= \frac{|{\rm EA}_x|}{|\overline{x}|}< \frac{0.1}{332.9} \approx 3.003\times 10^{-4}
\]
\[
|{\rm ER}_y|= \frac{|{\rm EA}_y|}{|\overline{y}|}< \frac{0.1}{1.4} \approx 0.071
\]
++++
Portanto, latexmath:[$x$ é representado com maior precisão que $y$].
====


//Em geral, nos procedimentos numéricos se gera uma sequencia de soluções aproximadas as quais no limite tendem ou não para a solução do problema.

==== Erros em um Sistema de Ponto Flutuante

A representação de um número em um sistema de ponto flutuante depende
do computador usado, devido a que o seu sistema estabelecerá a base
numérica adotada, o número de dígitos da mantissa, etc.

Sejam um número real latexmath:[$x$ e um equipamento que use o
seguinte ${\rm SPF}(10,n, \exp_{\rm min}, \exp_{\rm max})$. Então $x$]
pode ser reescrito como

[latexmath]
++++
\[
x=f_x\times 10^{\exp} + g_x\times 10^{\exp -n}
\]
++++
onde latexmath:[$0.1\leq f_x <1$ e $0\leq g_x <1$].  

[NOTE]
====
Nesta representação:
[latexmath]
++++
\[
nr_x=f_x\times 10^{\exp}
\]
++++
e latexmath:[$g_x\times 10^{\exp -n}$] é o valor que não pode ser incorporado totalmente à mantissa.
====

Por exemplo, consideremos latexmath:[$n=4$ e $x=123.45$], logo
[latexmath]
++++
\[
x=0.1234\times 10^{3} + 0.5\times 10^{-1}\qquad \mbox{e}\quad f_x=0.1234 \quad \mbox{e} \quad g_x= 0.5.  
\]
++++

Agora temos o problema de como considerar o valor de latexmath:[$g_x$]
dentro mantissa, e estabelecer o erro absoluto (ou relativo) máximo
cometido.


Como dito anteriormente, podemos adotar um dos seguintes critérios: 
[latexmath]
++++
\[
\mbox{truncar ou arredondar.}\]
++++


Quando consideramos o *truncamento*, o valor latexmath:[$g_x\times
10^{\exp -n}$] é desprezado, e o valor aproximado  é dado por:

[latexmath]
++++
\[
\overline{x}=f_x\times 10^{\exp}.
\]
Logo, $|g_x|<1$ implica que
\[
\begin{array}{rcl}
|{\rm EA}_x| &=& |x-\overline{x}| =  |g_x| \times 10^{\exp -n} < 10^{\exp -n}.
\end{array}
\]
Além disso, $1< \dfrac{1}{|f_x|} \leq \dfrac{1}{0.1}$ implica que
\[
\begin{array}{rcl}
|{\rm ER}_x| &=& \dfrac{|{\rm EA}_x|}{|\overline{x}|} =  \dfrac{|g_x| \times 10^{\exp -n}}{|f_x| \times 10^{\exp} } < \dfrac{10^{\exp -n}}{0.1\times 10^{\exp}} = 10^{-n+1}.
\end{array}
\]
++++

Quando consideramos o *arredondamento*, latexmath:[$f_x$ é modificado
para levar em conta o valor $g_x$]. A forma mais usada é o
arredondamento simétrico:

[latexmath]
++++
\[
\overline{x} = \left\{
 \begin{array}{ccl} 
f_x\times 10^{\exp}, && \mbox{se}\quad |g_x|< \dfrac{1}{2};\\
&&\\
f_x\times 10^{\exp} + 10^{\exp-n}, && \mbox{se}\quad |g_x| \geq \dfrac{1}{2}.
\end{array}
\right.
\]
++++

Em outras palavras, se latexmath:[$|g_x|< \dfrac{1}{2}$, então $g_x$ é
desprezado, caso contrário somamos o número $1$ ao último digito de
$f_x$]. Logo, 

* se latexmath:[$|g_x|<\frac{1}{2}$], então
+
[latexmath]
++++
\[
\begin{array}{l}
|{\rm EA}_x|= |x-\overline{x}| =|g_x|\times 10^{\exp-n} < \dfrac{1}{2}\times 10^{\exp-n};\\
\\
|{\rm ER}_x| = \dfrac{|{\rm EA}_x|}{|\overline{x}|} =  \dfrac{|g_x| \times 10^{\exp -n}}{|f_x| \times 10^{\exp }} < 
\dfrac{0.5\times 10^{\exp -n}}{0.1\times 10^{\exp}} = \dfrac{1}{2} \times 10^{-n+1};
\end{array}
\]
++++
* se latexmath:[$|g_x|\geq\frac{1}{2}$], então
+
[latexmath]
++++
\[
\begin{array}{rcl}
|{\rm EA}_x|&=& |x-\overline{x}| =\left|(f_x\times 10^{\exp} + g_x\times 10^{\exp -n}) - (f_x\times 10^{\exp} +10^{\exp -n}) \right|\\                  \\
      &= &\left| g_x \times 10^{\exp-n} - 10^{\exp-n}\right|=  |g_x -1|\times 10^{\exp-n} \\\\
&\leq& \frac{1}{2} \times 10^{\exp-n}\\
&&\\
|{\rm ER}_x| &=& \dfrac{|{\rm EA}_x|}{|\overline{x}|} =  \dfrac{\frac{1}{2} \times 10^{\exp -n}}{|f_x \times 10^{\exp}+ 10^{\exp}|} <  \dfrac{\frac{1}{2}\times 10^{\exp -n}}{|f_x|\times 10^{\exp}} 
\\\\
&<& \dfrac{\frac{1}{2}\times 10^{\exp -n}}{0.1\times 10^{\exp}}<  \frac{1}{2} \times 10^{-n+1}
\end{array}
\]
Portanto, em ambos casos obtemos que os erros absolutos e relativos podem ser limitados pelas seguintes expressões:
\[
|{\rm EA}_x| \leq \frac{1}{2} \times 10^{\exp-n}\qquad\mbox{e}\qquad |{\rm ER}_x|< \frac{1}{2} \times  10^{-n+1}
\]
++++
Embora, a geração de erros seja menor quando optamos por fazer
arredondamento, isto demanda de um  maior tempo de execução, e por
este motivo o truncamento é mais usado.

==== Propagação dos erros

Quando efetuamos operações num latexmath:[${\rm SPF}(\beta,n,
\exp_{\rm min}, \exp_{\rm max})$], como por exemplo:

[latexmath]
++++
\[
x=[(y+w)-z]+v
\]
++++

devemos levar  em conta a propagação dos erros, isto é, como o erro
numa operação se propaga ao longo das próximas  operações. Assim, o
erro total numa operação é composto pelo erro da aproximação dos
fatores e pelo erro no resultado da operação. 



.{zwsp}
====
Sejam latexmath:[$x=0.457\times 10^4$, $y=0.9168\times 10^2 \in {\rm SPF}(10,4, \exp_{\rm min}, \exp_{\rm max})$]. Calculemos latexmath:[$x+y$ e $x\times y$].

Solução::

.. latexmath:[$x+y$]: Para realizar uma soma em aritmética de ponto
   flutuante, é necessário que os números estejam alinhados, em
   relação ao ponto decimal. Assim, a mantissa do número de menor
   expoente deve ser deslocada para a direita as posições necessárias,
   isto é, o deslocamento deve ser de um número de casas decimais
   igual à diferença entre os dois expoentes. Logo,  latexmath:[$x$ e
   $y$] serão reescritos da seguinte forma
+
[latexmath]
++++
\[
x=0.457\times 10^4\quad \mbox{ e } \quad y=0.009168\times 10^4
\]
Desta forma, 
\[
x+y=(0.457+ 0.009168)\times 10^4=0.466168\times 10^4.
\]
++++
+
Desde que latexmath:[$n=4$], o resultado exato desta operação deve ser
arredondado ou truncado, para poder pertencer a latexmath:[${\rm
SPF}(10,4, \exp_{\rm min}, \exp_{\rm max})$]. Assim, se
+
--
... arredondamos, temos que: 
+
[latexmath]
++++
\[
\overline{x+y}= 0.4662\times 10^4;
\]
++++

... truncamos, temos que: 
+
[latexmath]
++++
\[
\overline{x+y}= 0.4661\times 10^4.
\]
++++
--

.. latexmath:[$x\times y$]: Para realizar o produto de dois números
   procedemos da forma habitual.
+
[latexmath]
++++
\[
x \times y =(0.457\times 10^4) \times(0.9168\times 10^2) = (0.457\times 0.9168)\times 10^6 = 0.4189776 \times 10^6
\]
++++
+
devido a que em nosso sistema latexmath:[$n=4$], o resultado deve de
ser arredondado ou truncado. Assim, se
+
--
... arredondamos, temos que: 
+
[latexmath]
++++
\[
\overline{x\times y}= 0.4190\times 10^6;
\]
++++

... truncamos, temos que: 
+
[latexmath]
++++
\[
\overline{x \times y}= 0.4189\times 10^6.
\]
++++
--
====


Do exemplo anterior, observamos que, embora os números envolvidos na
operação sejam representados num sistema de ponto flutuante
normalizado, não podemos esperar que o resultado também possa ser
representado neste sistema.

Quando trabalhamos num processo numérico, o processamento dos dados
pode envolver um certo número de operações elementares. Existem casos
em que o erro não é significativo para a solução do problema, porém em
geral é importante saber como os erros estão se propagando, pois isto
podem ou não afetar os resultados obtidos. 

... Caso o erro esteja se acumulando a uma taxa crescente, se diz que
o erro é *ilimitado*, e a sequência de operações é considerada
*instável*; o item (a) da figura abaixo ilustra este fato.

... Caso contrário, o erro esteja se acumulando a uma taxa
decrescente, se diz que o erro é *limitado*, e a sequência de
operações é considerada *estável*; o item (b) da figura abaixo ilustra
este fato.


image::images/cap1/Erro_lim_ilim.eps[scaledwidth="80%"]


.{zwsp}
====
Usando latexmath:[${\rm SPF}(10,4, \exp_{\rm min}, \exp_{\rm max})$], com aritmética de truncamento, calculemos o valor da seguinte soma:
[latexmath]
++++
\[
S= \sum\limits^{3}_{i=1}(x_i+y_i),\qquad \mbox{com}\quad x_i=0.51909\quad y_i=4.4878\quad \forall\,i=1,2,3. 
\]
++++

Solução:: Desde que estamos trabalhando em latexmath:[${\rm SPF}(10,4,
\exp_{\rm min}, \exp_{\rm max})$], temos que
+
[latexmath]
++++
\[
x_i=0.51909\quad\Rightarrow \quad  \overline{x}_i=0.519  \quad \mbox{e}\quad  y_i=4.4878\quad\Rightarrow \quad \overline{ y}_i=0.4487\times 10^{1} 
\]
++++
+
para todo latexmath:[$i=1,2,3.$]

... Para latexmath:[$i=1$] temos que: 
+
[latexmath]
++++
\[S_1=x_1 + y_1=0.51909+4.4878 = 0.500689 \times 10^1
\]
\[
\overline{S}_1=\overline{x}_1 + \overline{y}_1= 0.519 + 0.4487\times 10^{1}=0.5006 \times 10^1 
\]
Logo, o Erro absoluto é dado por:
\[
{\rm EA}_{1}=0.500689 \times 10^1- 0.5006\times 10^1= 0.000089\times 10^1= 0.89 \times 10^{-3}. 
\]
++++

... Para latexmath:[$i=2$] temos que: 
+
[latexmath]
++++
\[
S_2=(x_2 + y_2)+ (x_1 + y_1)=0.500689 \times 10^1 + 0.500689 \times 10^1= 0.1001378\times 10^2
\]
\[
\overline{S}_2= (\overline{x}_2 + \overline{y}_2)+ (\overline{x}_1 + \overline{y}_1)=0.5006 \times 10^1+ 0.5006 \times 10^1=0.10012 \times 10^2 \approx 0.1001 \times 10^2
\]
Logo, o Erro absoluto é dado por:
\[
{\rm EA}_{2}=0.1001378\times 10^2- 0.1001 \times 10^2= 0.0000378\times 10^2= 0.378 \times 10^{-2}. 
\]
++++

... Para latexmath:[$i=3$] temos que: 
+
[latexmath]
++++
\[
S_3=(x_3 + y_3)+(x_2 + y_2)+ (x_1 + y_1)= 0.1502067 \times 10^2
\]
\[
\overline{S}_3=(\overline{x}_3 + \overline{y}_3)+ (\overline{x}_2 + \overline{y}_2)+ (\overline{x}_1 + \overline{y}_1)= 0.15018 \times 10^2 \approx 0.1501 \times 10^2
\]
Logo, o Erro absoluto é dado por:
\[
 {\rm EA}_{3}=0.1502067 \times 10^2- 0.1501 \times 10^2= 0.0001067\times 10^2= 0.1067 \times 10^{-1}. 
\]
++++
////
... Para latexmath:[$i=4$] temos que: 
+
[latexmath]
++++
\[
\begin{array}{rcl}
S_4&=&(x_4 + y_4)+(x_3 + y_3)+(x_2 + y_2)+ (x_1 + y_1)\\
&=&  0.2002756 \times 10^2
\end{array}
\]
\[
\begin{array}{rcl}
\overline{S}_4&=&(\overline{x}_4 + \overline{y}_4)+(\overline{x}_3 + \overline{y}_3)+ (\overline{x}_2 + \overline{y}_2)+ (\overline{x}_1 + \overline{y}_1)\\
&=&  0.20024\times 10^2\approx 0.2002\times 10^2
\end{array}
\]
Logo, o Erro absoluto é dado por:
\[
{\rm EA}_{4}= 0.2002756 \times 10^2-  0.2002 \times 10^2= 0.0000756\times 10^2= 0.756 \times 10^{-2}. 
\]
++++
... Para latexmath:[$i=5$] temos que: 
+
[latexmath]
++++
\[
\begin{array}{rcl}
S_5&=&(x_5 + y_5)+(x_4 + y_4)+(x_3 + y_3)+(x_2 + y_2)+ (x_1 + y_1)\\
&=&0.500689 \times 10^1 +0.500689 \times 10^1 + 0.500689 \times 10^1 + 0.500689 \times 10^1 +0.500689 \times 10^1\\
&=&  0.2503445 \times 10^2
\end{array}
\]
\[
\overline{S}_5= 0.2503 \times 10^2
\]
Logo, o Erro absoluto é dado por:
\[
 {\rm EA}_{5}= 0.2503445 \times 10^2-  0.2503 \times 10^2= 0.0000445\times 10^2= 0.445 \times 10^{-2}. 
\]
++++
////
====

Neste exemplo, observamos que a medida que aumentam as operações de
adição e considerando a aritmética de ponto flutuante definida, o erro
absoluto cresce. Assim a medida que latexmath:[$i$] seja muito grande
a sequência de operações pode torna-se instalável.

.{zwsp}
====
Considere a sequência gerada por:
[latexmath]
++++
\[
x_{i+1}=\frac{1}{2} \left( x_i + \frac{2}{x_i} \right),\qquad \forall\, i=1,2,\ldots
\]
++++
Nesta sequência, estão envolvidas as operações de adição,
multiplicação e divisão, as quais são repetidas sucessivamente até
obter o valor aproximado de latexmath:[$x_i$, que deve ser uma solução
com a precisão desejada $\epsilon$].

Assim, o valor final latexmath:[$x_i$] possui um determinado tipo de
erro, o qual pode se propagar ao longo de todo o processo. Caso a
sequência convirja para um número, apesar dos erros cometidos na
obtenção de cada iteração, temos que a sequência de operações torna-se
estável. 

====



